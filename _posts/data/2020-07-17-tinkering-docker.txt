docker was one of these things that i always wanted to learn, but never got into. part of the reason was that it seemed distant and even somewhat unnecessary to me. as someone who has only worked on relatively simple projects, i never felt the need to go beyond the notion of virtual environments. indeed, when i first read about docker in an attempt to learn more about what all the devops hype was about, i found myself wondering: is docker really that much different from a python virtual environment? well, some time has passed since then, and i got lucky enough to have landed an internship at a small startup. given that the team will be using some devops tools docker definitely being one of them i thought i'd get my hands dirty to get a sense of what docker is like and what it's primarily used for. instead of the youtube route, this time i decided to check out a book titled docker deep dive by nigel poulton. throughout this post, i will be referring to examples from his book. for those who want to get a beginner friendly introduction to docker, i highly recommend this book. at the point of writing, i've read up to chapter 8 of the book, "containerizing an app," immediately before the next chapter on docker compose. this post is not intended as a comprehensive, well written introduction to docker; instead, it is in fact a playground environment i used to test out some docker commands as i was following along the book. with that out of the way, let's jump right in. before getting into any details about docker, it's perhaps necessary for me to clarify the setup in which this post was written. in testing out docker commands, i went back and forth between this jupyter notebook and the terminal. i mainly tried to use jupyter in order to record the commands i typed and their outputs in this post, but certain commands that require secondary input in interactive mode, such as was tested in the terminal. the sign in front of every docker command is necessary to run unix commands in jupyter. an exception is , which is a magic command in jupyter that allows the use of ; does not work, because the way jupyter interacts with the system is by attaching a shell subprocess. these details aside, the key takeaway is that the exclamation or percent symbols can be disregarded. in this section, we will learn about some basic docker commands to get started. here is the most basic one that allows us to check the version and configuration of docker: client: docker engine community version: 19.03.8 api version: 1.40 go version: go1.12.17 git commit: afacb8b built: wed mar 11 01:21:11 2020 os/arch: darwin/amd64 experimental: false server: docker engine community engine: version: 19.03.8 api version: 1.40 go version: go1.12.17 git commit: afacb8b built: wed mar 11 01:29:16 2020 os/arch: linux/amd64 experimental: false containerd: version: v1.2.13 gitcommit: 7ad184331fa3e55e52b890ea95e65ba581ae3429 runc: version: 1.0.0 rc10 gitcommit: dc9208a3303feef5b3839f4323d9beb36df0a9dd docker init: version: 0.18.0 gitcommit: fec3683 notice that the docker engine correctly identifies as as , whereas that of the server is noted as . in essence, this is saying that the server is running on a linux kernel. running a linux kernel on a macos host through docker is made possible via hypervisor and the linuxkit. at this point, all there is to know about the details is that docker originally used virtualbox to run a linux vm, but now uses a more lightweight setup thanks to the aforementioned tools. in unix, is a command that can be used to get a convenient list of files available in the current directory. similarly, can be used to look up what docker components are running or existent. for instance, to check which containers are running, we can type container id image command created status ports names if we want to check images instead of containers, we can simply replace the with . repository tag image id created size test latest 3ad97d9a5a5a 13 minutes ago 82.7mb alpine latest a24bb4013296 6 weeks ago 5.57mb golang 1.11 alpine e116d2efa2ab 10 months ago 312mb we can also use some filtering along with the command to target or specify our search. for instance, to search for only those images whose tags are , we can run repository tag image id created size test latest 3ad97d9a5a5a 2 hours ago 82.7mb ubuntu latest adafef2e596e 6 days ago 73.9mb alpine latest a24bb4013296 6 weeks ago 5.57mb to pull an image, we can use , where the ellipses are the name of the repository and the tag. for example, let's try pulling the latest ubuntu image from docker hub. latest: pulling from library/ubuntu 1b352adcf2: pulling fs layer 1b8a342707: pulling fs layer 1bb8e766f4: pulling fs layer 1bdigest: sha256:55cd38b70425947db71112eb5dddfa3aa3e3ce307754a3df2269069d2278ce474a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k1a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k3a2k2a2k1a2k status: downloaded newer image for ubuntu:latest docker.io/library/ubuntu:latest if we now check what images we have, we see the ubuntu image that was just pulled. repository tag image id created size test latest 3ad97d9a5a5a 13 minutes ago 82.7mb ubuntu latest adafef2e596e 6 days ago 73.9mb alpine latest a24bb4013296 6 weeks ago 5.57mb golang 1.11 alpine e116d2efa2ab 10 months ago 312mb we can also pull from other sources as well. in docker hub, there is this notion of namespaces. what this simply means is that some docker accounts, most likely huge companies or other established developers, have a first class namespace status. this means that the name of their repository is absolute. a good example is is a valid name of an image. for third party or individual developers like us, however, the namespace becomes slightly different. for example, to pull from poulton's repository on docker hub, we need to reference his image as :. for me, it would be . note that the name of the docker repository is effectively the name of the image. another useful thing to know about pulling is that docker intelligently knows when to pull new layers and when to use preexisting ones that are already on our system. for example, if i try pulling an image from docker hub, here is the output message i get on the terminal: latest: pulling from nigelpoulton/tu demo 1b3a933944: pulling fs layer 1b563217f5: pulling fs layer 1b7ec39263: pulling fs layer 1b26f0f7cc: pulling fs layer 1b2aee5115: pulling fs layer 1be9939cc3: pulling fs layer 1b38d27074: pulling fs layer 1b8469a194: pulling fs layer 1bdigest: sha256:c9f8e1882275d9ccd82e9e067c965d1406e8e1307333020a07915d6cbb9a74cf7a2k9a2k7a2k9a2k7a2k9a2k7a2k9a2k9a2k9a2k9a2k9a2k9a2k9a2k9a2k9a2k7a2k9a2k7a2k9a2k9a2k9a2k9a2k8a2k7a2k7a2k7a2k6a2k7a2k7a2k7a2k7a2k7a2k7a2k5a2k5a2k5a2k5a2k7a2k5a2k5a2k4a2k5a2k7a2k5a2k5a2k5a2k5a2k5a2k7a2k7a2k7a2k7a2k2a2k7a2k2a2k2a2k2a2k2a2k2a2k7a2k2a2k2a2k2a2k2a2k2a2k2a2k7a2k2a2k2a2k7a2k2a2k2a2k1a2k2a2k2a2k7a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k7a2k2a2k2a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k7a2k6a2k5a2k5a2k5a2k4a2k3a2k2a2k2a2k2a2k1a2k v1: pulling from nigelpoulton/tu demo 1b3a933944: already exists 1b563217f5: already exists 1b7ec39263: already exists 1b26f0f7cc: already exists 1b2aee5115: already exists 1be9939cc3: already exists 1b38d27074: already exists 1b8469a194: already exists 1bdigest: sha256:674cb034447ab34d442b8df03e0db6506a99390a1e282d126fb44af8598e4d2a v2: pulling from nigelpoulton/tu demo digest: sha256:c9f8e1882275d9ccd82e9e067c965d1406e8e1307333020a07915d6cbb9a74cf status: downloaded newer image for nigelpoulton/tu demo docker.io/nigelpoulton/tu demo notice that layers that already exist are skipped. for example, consider a situation where the docker image uses as a basis. then, since we already have in our system, docker simply assigns a pointer to reference that image instead of downloading duplicate contents again. a useful concept to have in mind when dealing with docker is the notion of images and containers. simply put, a docker image is a snapshot of this semi virtual machine. one can think of it as some sort of frozen specimen from which we can only read, not write. then how do use this image? this is where containers come in. containers are based off of images and allow users to interact with the virtual environment. for example, we can run the ubuntu image by spinning a container off of it through the following command: in docker commands, means interactive mode, meaning that the current terminal will turn into a command line interface within the docker container. due to constraints in jupyter, this process cannot be illustrated here, but you'll figure out what this means once you simply run the command. since we have a container running, if we use the command again but this time on containers we get the running container. notice that under the tab, we see the original image from which this container was created: . container id image command created status ports names 6258444a446a ubuntu:latest "/bin/bash" 35 seconds ago up 34 seconds compassionate_hofstadter we can stop containers that are running simply by explicitly stopping it. we can use either names or container ids to target the container we want to stop. compassionate_hofstadter but stopping a container doesn't mean that the container is gone. in fact, if we type , we see that is still on our system! container id image command created status ports names 6258444a446a ubuntu:latest "/bin/bash" about a minute ago exited 45 seconds ago compassionate_hofstadter a lot of times, we probably want to keep this docker container since we will probably be developing some application in this docker container. however, if we want to erase the container completely, we can use the command. compassionate_hofstadter and now we see that it is finally gone. container id image command created status ports names but of course, erasing a container doesn't mean that the image from which it was created is also deleted from the system. indeed, if we run on docker images, we still see . if we want to, we can always spin another container from this image. repository tag image id created size test latest 3ad97d9a5a5a 18 minutes ago 82.7mb ubuntu latest adafef2e596e 6 days ago 73.9mb alpine latest a24bb4013296 6 weeks ago 5.57mb golang 1.11 alpine e116d2efa2ab 10 months ago 312mb next, let's talk about dockerfiles. a dockerfile is a file that tells docker what sort of image we want to build. so far, we've only be dealing with default images available from docker hub, such as the latest version of ubuntu. but what if we want to build some customized image of our own for an application? after all, these images only contain absolutely necessary components. for instance, i've tried typing in the ubuntu image, but the command does not exist! so how do we build custom images? well, we basically stack images on top of each other. in this context, we call these images as layers. but the boundary between an image and a layer can get somewhat confusing, since an image composed of multiple images can be squashed into one layer, which would then produce one single layered image. but the overall idea is that we can stack components on top of each other to build a customized image. here is an example dockerfile from poulton's repository. from alpine label maintainer="nigelpoulton@hotmail.com" run apk add update nodejs nodejs npm copy . /src workdir /src run npm install expose 8080 entrypoint "node", "./app.js" in summary, we might visualize this docker image as follows: while this file is certainly not written in vernacular prose, we can sort of see what it's doing. first, we start some base image, which is in this case. then, we install some modules that will be necessary. we then copy the contents of the file to , a virtual directory in the docker container. then, we run some commands and expose the endpoint of the application. exposing the endpoint simply means that there is a port or url through which we can access the web application living in docker. as stated earlier, a dockerfile is a method of building custom images. how do we actually build an image off of it? all we need is a simple command. sending build context to docker daemon 100.9kb step 1/8 : from alpine a24bb4013296 step 2/8 : label maintainer="nigelpoulton@hotmail.com" using cache 2ead764f71cf step 3/8 : run apk add update nodejs nodejs npm using cache 6a652e727789 step 4/8 : copy . /src using cache 33eed66ed95e step 5/8 : workdir /src using cache e07f22f7a87b step 6/8 : run npm install using cache 57fcc62715f2 step 7/8 : expose 8080 using cache 889b9b226806 step 8/8 : entrypoint "node", "./app.js" using cache 3ad97d9a5a5a successfully built 3ad97d9a5a5a successfully tagged test:latest the in the command above simply tells docker that the dockerfile is available in the current directory. if it is in a subfolder, we will have to specify its location. now let's run the app! through on port 8080, we can now access the web application running on the docker container image. c6645ae79b55b87650c8468d1f605e34d3c22a948a2c99bf717f25753598f63a if we check which docker containers are up and running, we see the node application on the list right away. it also shows us the ports that are open. container id image command created status ports names c6645ae79b55 test:latest "node ./app.js" 19 seconds ago up 18 seconds 0.0.0.0:8080 8080/tcp web1 let's gracefully stop the container. c6645ae79b55 note that we can chain the two command together to gracefully stop and remove the container in one chained command. 8b867dd4a284 8b867dd4a284 earlier, we saw that the command could be used to delete docker images or containers. while this is true, there are certain things that we need to be careful of when deleting an image or container. for example, if we try to delete , we run into the following message: error response from daemon: conflict: unable to remove repository reference "alpine:latest" container 6295af1857c5 is using its referenced image a24bb4013296 this simply means that the image is referenced by another container, namely . from this, we can deduce that the dockerfile for probably starts off with , or at least uses as one of its layers at one point of the building process. like this, we need to make sure that one image is not a basis for another; only the children can be deleted, not its parent. sometimes, you might see images when you run commands for docker images. these might be dangling image layers, which can be checked for through the following command: repository tag image id created size to remove dangling layers, we can prune docker. warning! this will remove all dangling images. are you sure you want to continue? y/n ^c in some cases, however, pruning does not delete images. this means that these images are not dangling; most commonly, i've realized that these seemingly dangling images are simply the intermediate layers of some custom created image. a final note on a convenient command with which we can remove all current containers. although this is a one liner, it is really just a nested command in which we first look for containers that are open, get their identifications, and forcibly remove them from the system with the flag. note that enforcing does not constitute graceful shutdown and deletion, but it is a convenient command nonetheless. da65774cecf9 as mentioned earlier, docker hub is sort of the github for docker images. here, people can push and pull images that they themselves have created, or those that have been created by others. one convenient thing about docker hub is that we can use the command line interface to perform some quick searches. in this example, we search for poulton's images on docker hub, then pipe that result onto so that we don't end up getting too much search results. name description stars official automated nigelpoulton/pluralsight docker ci simple web app used in my pluralsight video â€¦ 23 ok nigelpoulton/tu demo voting web server used for various pluralsigâ€¦ 12 nigelpoulton/ctr demo web server for simple docker demos 3 nigelpoulton/k8sbook simple web app used for demos in the kuberneâ€¦ 2 nigelpoulton/vote fork of dockersamples voting app for dockerâ€¦ 1 nigelpoulton/dockerbook repo for examples used in docker deep dive bâ€¦ 0 nigelpoulton/msb hello 0 nigelpoulton/web fe1 web front end 0 nigelpoulton/workshop101 kubernetes 101 workshop. 0 we can also apply filters on our search, just like we saw earlier how we can use the command along with . for instance, let's try to search for an official docker image whose name is . spoiler alert: turns out that there is only one, since has first class namespace status. name description stars official automated alpine a minimal docker image based on alpine linuxâ€¦ 6613 ok when we deal with custom created images, it's probably a good idea to run a quick inspection on the image, just to be sure that everything looks good and nothing is suspicious. the command can be used in this context, and running it gives us this long json style output that tells us a lot about how the image was created and what layers there are within it. { "id": "sha256:adafef2e596ef06ec2112bc5a9663c6a4f59a3dfd4243c9cabe06c8748e7f288", "repotags": "ubuntu:latest" , "repodigests": "ubuntu@sha256:55cd38b70425947db71112eb5dddfa3aa3e3ce307754a3df2269069d2278ce47" , "parent": "", "comment": "", "created": "2020 07 06t21:56:31.471255509z", "container": "6255a9da773a5e0438e3c097b876a2de65d33f3fb57c4e515faed215d17b8b5d", "containerconfig": { "hostname": "6255a9da773a", "domainname": "", "user": "", "attachstdin": false, "attachstdout": false, "attachstderr": false, "tty": false, "openstdin": false, "stdinonce": false, "env": "path=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" , "cmd": "/bin/sh", " c", "cmd \"/bin/bash\"" , "argsescaped": true, "image": "sha256:8437baa15ca1576161e9e3f0981298a9c8f0c027e2f86b8d4336bb0d54c2896a", "volumes": null, "workingdir": "", "entrypoint": null, "onbuild": null, "labels": {} }, "dockerversion": "18.09.7", "author": "", "config": { "hostname": "", "domainname": "", "user": "", "attachstdin": false, "attachstdout": false, "attachstderr": false, "tty": false, "openstdin": false, "stdinonce": false, "env": "path=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" , "cmd": "/bin/bash" , "argsescaped": true, "image": "sha256:8437baa15ca1576161e9e3f0981298a9c8f0c027e2f86b8d4336bb0d54c2896a", "volumes": null, "workingdir": "", "entrypoint": null, "onbuild": null, "labels": null }, "architecture": "amd64", "os": "linux", "size": 73858282, "virtualsize": 73858282, "graphdriver": { "data": { "lowerdir": "/var/lib/docker/overlay2/a20140d993e4faac2bf8d1ab7aadc4aa5867fb7575a6f3a86a05e1b033df2ab8/diff:/var/lib/docker/overlay2/236b08d4cac34967fd2afe3effef4b8b5116a1ef7088cb1c6dbe216aabe920ca/diff:/var/lib/docker/overlay2/6aca6a67d2b1c73d377979b654af526637994474018c960915d1ac4a5503a353/diff", "mergeddir": "/var/lib/docker/overlay2/5d99fbc21081542a4f8c520abc58119aebadc3b6de40adfe6e404ab74cd7bbb2/merged", "upperdir": "/var/lib/docker/overlay2/5d99fbc21081542a4f8c520abc58119aebadc3b6de40adfe6e404ab74cd7bbb2/diff", "workdir": "/var/lib/docker/overlay2/5d99fbc21081542a4f8c520abc58119aebadc3b6de40adfe6e404ab74cd7bbb2/work" }, "name": "overlay2" }, "rootfs": { "type": "layers", "layers": "sha256:d22cfd6a8b16689838c570b91794ed18acc752a08a10bce891cc64acc1533b3f", "sha256:132bcd1e0eb5c706a017ff058b68d76c24f66f84120c51c7662de074a98cbe7a", "sha256:cf0f3facc4a307e4c36e346ddb777a73e576393575043e89d2ea536b693c3ff5", "sha256:544a70a875fc8e410b8a1389bf912e9536cf8167cbbfc1457bba355d5b7ce5c4" }, "metadata": { "lasttagtime": "0001 01 01t00:00:00z" } } okay, this is perhaps too much data, but there there are parts that are interesting that require our attention. for example, notice that under , the image shows us how many layers there are. granted, the layers are sha256 encrypted, so we can't really see what these individual layers are right away. nonetheless, we can still get an idea of who heavy the image is and how many layers it is composed of. potentially even more important that getting the number of layers from an inspection command is knowing what command the docker is instructed to run. for a better example, let's another image. { "id": "sha256:dd7a37fe7c1e6f3b9bcd1c51cad0a54fde3f393ac458af3b009b2032978f599d", "repotags": "nigelpoulton/pluralsight docker ci:latest" , "repodigests": "nigelpoulton/pluralsight docker ci@sha256:61bc64850a5f2bfbc65967cc33feaae8a77c8b49379c55aaf05bb02dcee41451" , "parent": "", "comment": "", "created": "2020 01 18t15:29:24.3067368z", "container": "5e6c8e135f3504d8cdbb3b0f4f7658018f7eafa99011bcb0252c34bad246844f", "containerconfig": { "hostname": "5e6c8e135f35", "domainname": "", "user": "", "attachstdin": false, "attachstdout": false, "attachstderr": false, "exposedports": { "8080/tcp": {} }, "tty": false, "openstdin": false, "stdinonce": false, "env": "path=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" , "cmd": "/bin/sh", " c", "cmd \"/bin/sh\" \" c\" \"cd /src && node ./app.js\"" , "image": "sha256:3eee35387b69036be84160c16d756c975ce6445f5460b19ada2c343d796a0a17", "volumes": null, "workingdir": "", "entrypoint": null, "onbuild": null, "labels": { "maintainer": "nigelpoulton@hotmail.com", "org.label schema.build date": "20190927", "org.label schema.license": "gplv2", "org.label schema.name": "centos base image", "org.label schema.schema version": "1.0", "org.label schema.vendor": "centos" } }, "dockerversion": "19.03.4", "author": "", "config": { "hostname": "", "domainname": "", "user": "", "attachstdin": false, "attachstdout": false, "attachstderr": false, "exposedports": { "8080/tcp": {} }, "tty": false, "openstdin": false, "stdinonce": false, "env": "path=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" , "cmd": "/bin/sh", " c", "cd /src && node ./app.js" , "image": "sha256:3eee35387b69036be84160c16d756c975ce6445f5460b19ada2c343d796a0a17", "volumes": null, "workingdir": "", "entrypoint": null, "onbuild": null, "labels": { "maintainer": "nigelpoulton@hotmail.com", "org.label schema.build date": "20190927", "org.label schema.license": "gplv2", "org.label schema.name": "centos base image", "org.label schema.schema version": "1.0", "org.label schema.vendor": "centos" } }, "architecture": "amd64", "os": "linux", "size": 604213387, "virtualsize": 604213387, "graphdriver": { "data": { "lowerdir": "/var/lib/docker/overlay2/72128cfba240aa98c5b9d2b485463872b2e56f339ce69d5908afe9ca6e4fb31d/diff:/var/lib/docker/overlay2/45b41ad373af200b3751eeaaea1723f76af3340fe98518e31370cbb5c964a225/diff:/var/lib/docker/overlay2/3ac85bfcadfbf8445f596a31d93cf5e20cd4897986abea6a3d1f9d3f56026dee/diff:/var/lib/docker/overlay2/0c23839d4de34d644ad866812e2ba1a850d367fb903f1933f121acf74e677eff/diff:/var/lib/docker/overlay2/d98e0f531b232eeb37ddfa4f188c6518737322967bbbd02363e42808903b9d16/diff", "mergeddir": "/var/lib/docker/overlay2/ea7d7135f789fe192fa518ac788d86331a50a512d5bb4c7f17ab4b898f1f3737/merged", "upperdir": "/var/lib/docker/overlay2/ea7d7135f789fe192fa518ac788d86331a50a512d5bb4c7f17ab4b898f1f3737/diff", "workdir": "/var/lib/docker/overlay2/ea7d7135f789fe192fa518ac788d86331a50a512d5bb4c7f17ab4b898f1f3737/work" }, "name": "overlay2" }, "rootfs": { "type": "layers", "layers": "sha256:9e607bb861a7d58bece26dd2c02874beedd6a097c1b6eca5255d5eb0d2236983", "sha256:295c91644e82f1407550c700f1517e814dfa34512ee71ac82ccd4737ca44ea4d", "sha256:07ef3e9a214efe1d68365952f4376a7f8699ce9a5f8b6dc5788347759f334e8c", "sha256:ad1a639ad455b481e4723f3c546a623eac28c86ac961d8b173dab7507f62e122", "sha256:13dba83733f937ac8633ce7b6ebec222ec51d6bbe3f247cf4e652d67fe22c913", "sha256:35467005de8ad904fcc55d34fd5f6bcead2f8b9d97113aa4115130ee9dfa92d7" }, "metadata": { "lasttagtime": "0001 01 01t00:00:00z" } } if you look closely at the output, at one point you will see the section, which looks like this: this section tells us exactly what command the docker container is supposed to run. in this particular instance, we know that the command translates to the part that is in quotation marks is the actual command. from the looks of it, when the container is spun up, it will into the directly and run a node application. nice! so far, the only thing we know about running a container is that is an interactive mode and that running can simply be achieved with . there are some other details that might be helpful to know, in particular relating to automatic restarts. for example, we can pass in some flags such as , , and to specify what action the docker container should take when something breaks down, causing a halt. also note that we specified the name of the container in the example commands above as . we can also micro configure the container by specifically mapping ports from one to another. for example, if we run then we would be able to access the container on port 80. in other words, we would be browsing into , which would effectively be equivalent to browsing into port within the container. these are useful techniques that might come in handy when building a web application. so far, we've looked at pulling docker images from docker hub. we can also push our own images as well. as a simple example, let's take a look at how we might retag an image and perform a simple push. repository tag image id created size web latest 34b07893e6cf 10 seconds ago 82.8mb ubuntu latest adafef2e596e 6 days ago 73.9mb alpine latest a24bb4013296 6 weeks ago 5.57mb nigelpoulton/pluralsight docker ci latest dd7a37fe7c1e 5 months ago 604mb golang 1.11 alpine e116d2efa2ab 10 months ago 312mb the command basically uses a preexisting image and re tags it as specified. in this case, we've retagged into . if we look at the images that are on our system, we see the newly tagged image as well. repository tag image id created size jaketae/web latest 34b07893e6cf 30 minutes ago 82.8mb web latest 34b07893e6cf 30 minutes ago 82.8mb ubuntu latest adafef2e596e 6 days ago 73.9mb alpine latest a24bb4013296 6 weeks ago 5.57mb nigelpoulton/pluralsight docker ci latest dd7a37fe7c1e 5 months ago 604mb golang 1.11 alpine e116d2efa2ab 10 months ago 312mb now pushing is extremely easy: all we need to do is to use the command , where the ellipses contain the repository and tag of the image that we want to push. note that retagging was necessary for us to be able to use our own namespace equivalently, the docker id on docker hub. the push refers to repository docker.io/jaketae/web 1b8b6e0356: preparing 1b9a0747a8: preparing 1ba1bd40b4: preparing 2ba1bd40b4: pushed 54.46mb/51mb5mbine 2k1a2k4a2k2a2k4a2k2a2k4a2k2a2k4a2k2a2k2a2k4a2k3a2k4a2k4a2k4a2k2a2k4a2k4a2k4a2k2a2k4a2k2a2k4a2k2a2k4a2k4a2k2a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k4a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k4a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2k2a2klatest: digest: sha256:ffac23f83cc6f8e6a888db08dc95eca411b13548db499be994f24c26826ac532 size: 1161 in this post, we took a very quick blitz into the world of docker, images, and containers. the more i self study, the more i realize that i'm more of a person who learns through a hands on approach. i think this is especially the case when learning a new technology which allows one to tinker with and interact with the tools being used. i felt this when learning things like spark, and i feel it again in this post. on a special note, i will be working as a backend software development intern for a yale som based startup called rerent. i'm so excited about this opportunity, and i can't wait to apply my knowledge of docker in real production environments as we develop and deploy apps into the cloud. at the same time, however, this also means that i will probably be unable to write as many posts as i used to prior to work. i hope to find a good balance between working and self studying. i might also write posts about things i learn through the internship, such as django, using aws, and many more. thanks for reading this post. see you in the next one!